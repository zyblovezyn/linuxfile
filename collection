2019-03-30
	duplicate 重复
	declare duplicate_key condition for 1062;
	declare continue handler for duplicate_key set variable=1;

2019-04-01
	YEAR   		 1byte
	DATE	        3byte
	TIME		3byte+fractional seconds storage
	DATETIME	5byte+fractional seconds storage	
	TIMESTAMP	4byte+franctional seconds storage

	Fractional Seconds Precison	Storage Required
	0				0 bytes
	1,2				1 byte
	3,4				2 bytes
	5,6				3 bytes


	Data Type	Storage Required
	TINYINT		1 byte
	SMALLINT	2 bytes
	MEDIUMINT	3 bytes
	INT, INTEGER	4 bytes
	BIGINT		8 bytes
	FLOAT(p)	4 bytes if 0 <= p <= 24, 8 bytes if 25 <= p <= 53
	FLOAT		4 bytes
	DOUBLE [PRECISION], REAL	8 bytes
	DECIMAL(M,D), NUMERIC(M,D)	
	BIT(M)	approximately (M+7)/8 bytes


	CMS concurrent mark sweep 收集器
	
	decimal(18,9) 小数点前面9位数4个字节 小数点后面9个数4个字节 小数点一个字节 总用9个字节
	使用枚举类型(ENUM)代替字符串类型 枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举是非常紧凑，会根据列表值得数量压缩到一个或两个字节中。
	create table enum_table(
	  e enum('fish','dog','apple') not null
	);
	inert into enum_table(e) values('dog'),('apple'),('fish');
	
2019-04-02
	mysql把bit当做字符串类型，最多可以存储64位
	整数作为标识符是最好的选择
	避免使用字符串作为标识，因为比数字慢，在myisam中对字符串标识列使用压缩索引，导致查询很慢，测试表示，最多慢6倍

	如果希望查询性能比较好，最好限制在12个关联查询之内
	mysql在索引中存储null值，oracle则不会
	创建表结构 create table a_copy_tbl like a_tbl;
	rename table tbl_name to new_tbl;
	所有的modify column都将导致重建表
	alter table tbl modify column col_name tinyint(3) not null default 5;速度比较慢导致了重建表
	alter table tbl alter column col_name set default 5;没有导致重建表
	
	-XX:+PrintGCDetails 这个参数告诉虚拟机在发生垃圾收集行为时打印内存回收日志。

	-Xms 堆的最小值
	-Xmx 堆的最大值
	-Xss 线程堆栈大小
	-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时Dump出当前内存堆转储快照以便事后
	进行分析

	Memory leak 内存泄漏
	Memory Overflow 内存溢出

	如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowEror异常
	如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常

	MaxPermSize 最大方法区容量

	由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制>其中常量池的容量

	-XX:MaxDirectMemorySize 本机直接内存最大值 如果不指定与Java堆最大值(-Xms指定)一样

	程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。

	新生代GC(Minor GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也非常快。
	老年代GC(Major GC/Full GC):指发生在老年代的GC，出现Major GC，经常会伴随至少一次的Minor GC(但并非绝对)，Major GC的速度一般会比Minor GC的速度慢10倍以上。
	对象进入老年代的阈值，可以通过参数-XX:MaxTenuringThreshold:num设置。
	jps JVM process status tool,显示指定系统内所有的HotSpot虚拟机进程
	    主要参数:-q 输出LVMID，省略主类的名称
	    	     -m 输出虚拟机进程启动时传递给主类main()函数的参数
		     -l 输出主类的全名，如果程序执行的时Jar包，输出Jar路径
		     -v 输出虚拟机进程启动时JVM参数
	jstat JVM Statistics Monitoring Tool 监视虚拟机运行状态信息的命令行工具





2019-04-03
	mysql sql_calc_found_rows的使用计算出查询出生的行
	SELECT SQL_CALC_FOUND_ROWS * FROM a;
	SELECT FOUND_ROWS();
	locate(substr,str)字符串定位函数 子串在字符串中返回字符串中的位置(从1开始) 不在返回0
	locate('2','123') 返回2 
	locate('0','123') 返回0

	为了高效的把数据载入到MyISAM中可以：此方法对非唯一所以有效 唯一索引无效

	表和索引行都存储在页中，页的大小一般为4KB
	
	alter table test.load_tbl disable key
	load data
	alter table test.load_tbl enable key

	
	在高性能硬件上部署程序，目前主要有两种方式
	1 通过64位JDK来使用大内存
	2 使用若干个32位虚拟机建立逻辑集群来利用硬件资源

	（1）-Xms20M 表示设置JVM启动内存的最小值为20M，必须以M为单位

	（2）-Xmx20M 表示设置JVM启动内存的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免JVM内存自动扩展。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高

	（3）-verbose:gc 表示输出虚拟机中GC的详细情况

	（4）-Xss128k 表示可以设置虚拟机栈的大小为128k

	（5）-Xoss128k 表示设置本地方法栈的大小为128k。不过HotSpot并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说这个参数是无效的

	（6）-XX:PermSize=10M 表示JVM初始分配的永久代的容量，必须以M为单位

	（7）-XX:MaxPermSize=10M 表示JVM允许分配的永久代的最大容量，必须以M为单位，大部分情况下这个参数默认为64M

	（8）-Xnoclassgc 表示关闭JVM对类的垃圾回收

	（9）-XX:+TraceClassLoading 表示查看类的加载信息

	（10）-XX:+TraceClassUnLoading 表示查看类的卸载信息

	（11）-XX:NewRatio=4 表示设置年轻代：老年代的大小比值为1：4，这意味着年轻代占整个堆的1/5

	（12）-XX:SurvivorRatio=8 表示设置2个Survivor区：1个Eden区的大小比值为2:8，这意味着Survivor区占整个年轻代的1/5，这个参数默认为8

	（13）-Xmn20M 表示设置年轻代的大小为20M

	（14）-XX:+HeapDumpOnOutOfMemoryError 表示可以让虚拟机在出现内存溢出异常时Dump出当前的堆内存转储快照

	（15）-XX:+UseG1GC 表示让JVM使用G1垃圾收集器

	（16）-XX:+PrintGCDetails 表示在控制台上打印出GC具体细节

	（17）-XX:+PrintGC 表示在控制台上打印出GC信息

	（18）-XX:PretenureSizeThreshold=3145728 表示对象大于3145728（3M）时直接进入老年代分配，这里只能以字节作为单位

	（19）-XX:MaxTenuringThreshold=1 表示对象年龄大于1，自动进入老年代

	（20）-XX:CompileThreshold=1000 表示一个方法被调用1000次之后，会被认为是热点代码，并触发即时编译

	（21）-XX:+PrintHeapAtGC 表示可以看到每次GC前后堆内存布局

	（22）-XX:+PrintTLAB 表示可以看到TLAB的使用情况

	（23）-XX:+UseSpining 开启自旋锁

	（24）-XX:PreBlockSpin 更改自旋锁的自旋次数，使用这个参数必须先开启自旋锁
	
	shell中 $((数学表达式)) 
	$$使用脚本的进程ID
	let "赋值表达式或算数表达式"
	let "var1=12"   let "var2+=1"

